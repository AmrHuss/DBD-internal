#define _CRT_SECURE_NO_WARNINGS

#include "Overlay/overlay.h" // Your header file where overlay namespace and function declarations are
#include <imgui.h>
#include <windows.h>
#include <imgui_impl_dx11.h> // If using DX11
#include <imgui_impl_win32.h> // If using Win32
#include <string>
#include <string>
#include "../Utils/Game.h" // For Game::Controller, Game::Player, etc.
#include "../Utils/Logger.h" // For Utils::LogMessage


namespace overlay {
    // Define the master overlay switch
    // In overlay.cpp
    bool weaponChamsEnabled = false;
   ImColor weaponChamsColorImGui = ImColor(255, 0, 255, 255); // Bright Pink
    bool enabled = true; 
    // Define ESP-related variables
    float glowEspIntensity = 0.5f;          // Default glow intensity
    float healthBarWidth = 5.0f;            // Default health bar width
    ImU32 snaplineColor = IM_COL32(255, 255, 255, 255); // Default white
    bool mainEspBoxEnabled = false;         // Default off
    float mainEspBoxColor[3] = { 1.0f, 0.0f, 0.0f }; // Default red
    ImU32 textEspColor = IM_COL32(255, 255, 255, 255); // Default white
    bool cornerEspBoxEnabled = false;       // Default off
    float cornerEspBoxColor[3] = { 0.0f, 1.0f, 0.0f }; // Default green
    float headDotRadius = 3.0f;             // Default head dot size
    bool glowEspEnabled = false;            // Default off
    ImU32 lineToEnemyColor = IM_COL32(255, 0, 0, 255); // Default red
    float cornerEspBoxThickness = 1.5f;     // Default thickness
    float fovCircleRadius = 100.0f;         // Default FOV circle radius
    ImU32 fovCircleColor = IM_COL32(255, 255, 255, 128); // Default semi-transparent white
    float distanceUnitConversion = 100.0f;  // Default (e.g., cm to meters, adjust as needed)
    float mainEspBoxThickness = 2.0f;       // Default thickness
    float cornerFraction = 0.2f;            // Default corner box fraction
    ImVec2 snaplineOrigin = ImVec2(0.0f, 0.0f); // Default, should be updated dynamically
    ImU32 headDotColor = IM_COL32(255, 0, 0, 255); // Default red
    bool aimbotEnabled = false;
    float aimbotFov = 30.0f;
    float aimbotSmoothness = 0.5f;
    bool disableAimbotFlashed = false;
    bool disableAimbotSmoke = false;
    bool disableAimbotJump = false;
    bool triggerbotEnabled = false;
    bool teleport = false;
    // ESP - Core
    bool espEnabled = false; // Master ESP switch, changed from true to false
    float espColor[3] = { 0.0f, 1.0f, 0.0f }; // Neon green by default

    // ESP - Box Types
    bool boxEnabled = false;         // Full boxes, changed from true to false
    bool cornerBoxEnabled = false;   // Corner boxes
    bool gadgetEspEnabled = false;
    ImU32 gadgetEspColor; // Will be initialized in InitializeColors
    bool showGadgetName = false;
    bool showGadgetDistance = false;

    ImU32 glowColor; // Will be initialized in InitializeColors

    bool vehicleEspEnabled = false;
    ImU32 vehicleEspColor; // Will be initialized in InitializeColors
    bool showVehicleName = false;
    bool showVehicleDistance = false;
    bool showVehicleRider = false; // Added this one too

    ImU32 healthBarHighColor; // Will be initialized in InitializeColors
    ImU32 healthBarMidColor;  // Will be initialized in InitializeColors
    ImU32 healthBarLowColor;   // Will be initialized in InitializeColors

    ImU32 friendlyEspColor;   // Will be initialized in InitializeColors
    ImU32 enemyEspColor;      // Will be initialized in InitializeColors

    ImU32 espVisibleColor;    // Will be initialized in InitializeColors
    ImU32 espOccludedColor;   // Will be initialized in InitializeColors


    // ESP - Information & Effects
    bool boneEspEnabled = false;     // Skeletons, changed from true to false
    bool glowEnabled = false;        // General ESP glow
    float glowIntensity = 0.5f;
    bool healthBarEnabled = false;   // Health bars, changed from true to false

    // ESP - Additional Features (NEW - initialized to false)
    bool nameEspEnabled = false;
    bool healthTextEnabled = false;
    bool distanceEspEnabled = false;
    bool snaplinesEnabled = false;
    bool headDotEnabled = false;
    bool fovCircleEnabled = false;         // ESP Target FOV Circle
    bool lineToClosestEnemyEnabled = false;

    // Radar
    bool radarEnabled = false;       // Radar, changed from true to false (was radarHackEnabled before)

    // Misc
    bool bhopEnabled = false;// Default to true, or false based on your preference


    void InitializeColors() {
        // Initialize ImU32 colors here to avoid static initialization order issues
        // General
        textEspColor = IM_COL32(255, 255, 255, 255);
        // Glow
        glowColor = IM_COL32(255, 0, 0, 150); // Example: Red glow
        // Health Bar
        healthBarHighColor = IM_COL32(0, 255, 0, 255);   // Green
        healthBarMidColor = IM_COL32(255, 255, 0, 255);  // Yellow
        healthBarLowColor = IM_COL32(255, 0, 0, 255);    // Red
        // Snaplines
        snaplineColor = IM_COL32(255, 255, 255, 100);
        // Head Dot
        headDotColor = IM_COL32(255, 0, 0, 255);
        // FOV Circle
        fovCircleColor = IM_COL32(255, 255, 255, 100);
        // Line to Closest
        lineToEnemyColor = IM_COL32(255, 0, 0, 180);
        // Team Colors
        friendlyEspColor = IM_COL32(0, 255, 0, 255); // Green
        enemyEspColor = IM_COL32(255, 0, 0, 255);    // Red
        // Visibility Colors
        espVisibleColor = IM_COL32(0, 255, 0, 255);  // Bright Green
        espOccludedColor = IM_COL32(255, 165, 0, 180); // Orange-ish, semi-transparent
        // Gadget ESP
        gadgetEspColor = IM_COL32(0, 150, 255, 200); // Light Blue
        // Vehicle ESP
        vehicleEspColor = IM_COL32(255, 255, 0, 200); // Yellow
    }

}



// --- End of Global Settings Variables ---


void setup_skeet_style() {
    ImGuiStyle& style = ImGui::GetStyle();
    style.WindowPadding = ImVec2(10, 10);
    style.FramePadding = ImVec2(8, 4);
    style.ItemSpacing = ImVec2(8, 6);
    style.ItemInnerSpacing = ImVec2(6, 6);
    style.ScrollbarSize = 12.0f;
    style.GrabMinSize = 10.0f;
    style.WindowBorderSize = 0.0f;
    style.FrameBorderSize = 0.0f;
    style.PopupBorderSize = 0.0f;
    style.FrameRounding = 4.0f;
    style.GrabRounding = 4.0f;
    style.ScrollbarRounding = 4.0f;
    style.WindowRounding = 6.0f;

    ImVec4* colors = style.Colors;
    colors[ImGuiCol_Text] = ImVec4(0.90f, 0.90f, 0.90f, 1.00f);
    colors[ImGuiCol_TextDisabled] = ImVec4(0.50f, 0.50f, 0.50f, 1.00f);
    colors[ImGuiCol_WindowBg] = ImVec4(0.10f, 0.10f, 0.12f, 0.95f);
    colors[ImGuiCol_ChildBg] = ImVec4(0.12f, 0.12f, 0.14f, 0.90f);
    colors[ImGuiCol_PopupBg] = ImVec4(0.12f, 0.12f, 0.14f, 0.94f);
    colors[ImGuiCol_Border] = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
    colors[ImGuiCol_BorderShadow] = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
    colors[ImGuiCol_FrameBg] = ImVec4(0.15f, 0.15f, 0.17f, 1.00f);
    colors[ImGuiCol_FrameBgHovered] = ImVec4(0.20f, 0.20f, 0.25f, 0.80f);
    colors[ImGuiCol_FrameBgActive] = ImVec4(0.25f, 0.25f, 0.30f, 1.00f);
    colors[ImGuiCol_TitleBg] = ImVec4(0.08f, 0.08f, 0.10f, 1.00f);
    colors[ImGuiCol_TitleBgActive] = ImVec4(0.10f, 0.10f, 0.12f, 1.00f);
    colors[ImGuiCol_TitleBgCollapsed] = ImVec4(0.08f, 0.08f, 0.10f, 0.75f);
    colors[ImGuiCol_MenuBarBg] = ImVec4(0.15f, 0.15f, 0.17f, 0.90f);
    colors[ImGuiCol_ScrollbarBg] = ImVec4(0.08f, 0.08f, 0.10f, 0.90f);
    colors[ImGuiCol_ScrollbarGrab] = ImVec4(0.15f, 0.15f, 0.17f, 1.00f);
    colors[ImGuiCol_ScrollbarGrabHovered] = ImVec4(0.20f, 0.40f, 0.50f, 1.00f);
    colors[ImGuiCol_ScrollbarGrabActive] = ImVec4(0.25f, 0.45f, 0.55f, 1.00f);
    colors[ImGuiCol_CheckMark] = ImVec4(0.20f, 0.40f, 0.50f, 1.00f);
    colors[ImGuiCol_SliderGrab] = ImVec4(0.20f, 0.40f, 0.50f, 1.00f);
    colors[ImGuiCol_SliderGrabActive] = ImVec4(0.25f, 0.45f, 0.55f, 1.00f);
    colors[ImGuiCol_Button] = ImVec4(0.15f, 0.15f, 0.17f, 1.00f);
    colors[ImGuiCol_ButtonHovered] = ImVec4(0.20f, 0.40f, 0.50f, 1.00f);
    colors[ImGuiCol_ButtonActive] = ImVec4(0.25f, 0.45f, 0.55f, 1.00f);
    colors[ImGuiCol_Header] = ImVec4(0.15f, 0.15f, 0.17f, 1.00f);
    colors[ImGuiCol_HeaderHovered] = ImVec4(0.20f, 0.40f, 0.50f, 1.00f);
    colors[ImGuiCol_HeaderActive] = ImVec4(0.25f, 0.45f, 0.55f, 1.00f);
    colors[ImGuiCol_Separator] = ImVec4(0.20f, 0.20f, 0.22f, 1.00f);
    colors[ImGuiCol_SeparatorHovered] = ImVec4(0.20f, 0.40f, 0.50f, 1.00f);
    colors[ImGuiCol_SeparatorActive] = ImVec4(0.25f, 0.45f, 0.55f, 1.00f);
    colors[ImGuiCol_ResizeGrip] = ImVec4(0.15f, 0.15f, 0.17f, 0.75f);
    colors[ImGuiCol_ResizeGripHovered] = ImVec4(0.20f, 0.40f, 0.50f, 1.00f);
    colors[ImGuiCol_ResizeGripActive] = ImVec4(0.25f, 0.45f, 0.55f, 1.00f);
    colors[ImGuiCol_Tab] = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
    colors[ImGuiCol_TabHovered] = ImVec4(0.20f, 0.40f, 0.50f, 1.00f);
    colors[ImGuiCol_TabActive] = ImVec4(0.15f, 0.30f, 0.40f, 1.00f);
    colors[ImGuiCol_TabUnfocused] = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
    colors[ImGuiCol_TabUnfocusedActive] = ImVec4(0.10f, 0.10f, 0.12f, 1.0f);
    colors[ImGuiCol_PlotLines] = ImVec4(0.20f, 0.40f, 0.50f, 1.00f);
    colors[ImGuiCol_PlotLinesHovered] = ImVec4(0.25f, 0.50f, 0.60f, 1.00f);
    colors[ImGuiCol_PlotHistogram] = ImVec4(0.20f, 0.40f, 0.50f, 1.00f);
    colors[ImGuiCol_PlotHistogramHovered] = ImVec4(0.25f, 0.50f, 0.60f, 1.00f);
    colors[ImGuiCol_TextSelectedBg] = ImVec4(0.20f, 0.40f, 0.50f, 0.50f);
    colors[ImGuiCol_DragDropTarget] = ImVec4(0.20f, 0.40f, 0.50f, 0.90f);
    colors[ImGuiCol_NavHighlight] = ImVec4(0.20f, 0.40f, 0.50f, 1.00f);
    colors[ImGuiCol_NavWindowingHighlight] = ImVec4(1.00f, 1.00f, 1.00f, 0.70f);
    colors[ImGuiCol_NavWindowingDimBg] = ImVec4(0.80f, 0.80f, 0.80f, 0.20f);
    colors[ImGuiCol_ModalWindowDimBg] = ImVec4(0.10f, 0.10f, 0.12f, 0.75f);
}


namespace overlay {
    // Assuming 'overlay::enabled' is the master switch for the whole menu
    // It should be declared in overlay.h as 'extern bool enabled;'
    // and defined here (or wherever your main overlay logic is) as 'bool overlay::enabled = true;'

    void draw_gui() {
        if (!overlay::enabled) return; // Check master overlay switch from overlay.h

        setup_skeet_style();

        ImGui::SetNextWindowSize(ImVec2(800, 600), ImGuiCond_FirstUseEver);
        // Pass the address of the master overlay switch to ImGui::Begin
        // so closing the window sets overlay::enabled to false.
        ImGui::Begin("Killuano Ud Menu", &overlay::enabled, ImGuiWindowFlags_NoCollapse);

        ImGuiStyle& style = ImGui::GetStyle();

        // Header Text
        ImGui::TextColored(ImVec4(0.20f, 0.40f, 0.50f, 1.00f), "DeltaForce");
        ImGui::Separator();

        // Sidebar
        ImGui::BeginChild("Sidebar", ImVec2(200, ImGui::GetContentRegionAvail().y - (ImGui::GetTextLineHeightWithSpacing() + style.FramePadding.y * 2.0f + style.ItemSpacing.y)), true, ImGuiWindowFlags_NoScrollbar);
        static int selectedTab = 0;
        const char* tabNames[] = { "Aimbot", "Visuals", "Misc" };
        float button_width = ImGui::GetContentRegionAvail().x - style.WindowPadding.x;

        for (int i = 0; i < IM_ARRAYSIZE(tabNames); ++i) {
            bool is_selected = (selectedTab == i);
            if (is_selected) {
                ImGui::PushStyleColor(ImGuiCol_Button, style.Colors[ImGuiCol_TabActive]);
                ImGui::PushStyleColor(ImGuiCol_ButtonHovered, style.Colors[ImGuiCol_TabActive]);
            }

            if (ImGui::Button(tabNames[i], ImVec2(button_width, 30))) {
                selectedTab = i;
            }

            if (is_selected) {
                ImGui::PopStyleColor(2);
            }
        }
        ImGui::EndChild();
        ImGui::SameLine();

        // Main content area
        ImGui::BeginChild("Content", ImVec2(0, ImGui::GetContentRegionAvail().y - (ImGui::GetTextLineHeightWithSpacing() + style.FramePadding.y * 2.0f + style.ItemSpacing.y)), true);
        if (selectedTab == 0) { // Aimbot tab
            ImGui::TextColored(ImVec4(0.20f, 0.40f, 0.50f, 1.00f), "Aimbot Settings");
            ImGui::Separator();
            ImGui::Checkbox("Enable Aimbot", &aimbotEnabled); // Using global var
            if (ImGui::IsItemHovered()) ImGui::SetTooltip("Toggles aimbot functionality.");
            ImGui::Text("Aimbot Status: %s", aimbotEnabled ? "Enabled" : "Disabled");
            ImGui::SliderFloat("Aimbot FOV", &aimbotFov, 10.0f, 90.0f, "%.1f degrees");
            if (ImGui::IsItemHovered()) ImGui::SetTooltip("Field of view for aimbot targeting.");
            ImGui::SliderFloat("Aimbot Smoothness", &aimbotSmoothness, 0.1f, 1.0f, "%.2f");
            if (ImGui::IsItemHovered()) ImGui::SetTooltip("Adjusts aimbot smoothing.");
            ImGui::Checkbox("Disable if Flashed", &disableAimbotFlashed);
            if (ImGui::IsItemHovered()) ImGui::SetTooltip("Disables aimbot when flashed.");
            ImGui::Checkbox("Disable if in Smoke", &disableAimbotSmoke);
            if (ImGui::IsItemHovered()) ImGui::SetTooltip("Disables aimbot when enemy is in smoke.");
            ImGui::Checkbox("Disable if Jumping", &disableAimbotJump);
            if (ImGui::IsItemHovered()) ImGui::SetTooltip("Disables aimbot when jumping.");
            ImGui::Text("Hotkey: Insert");
            if (ImGui::IsItemHovered()) ImGui::SetTooltip("Press Insert to toggle aimbot (Visual reminder).");
            ImGui::Checkbox("Enable Triggerbot", &triggerbotEnabled);
            if (ImGui::IsItemHovered()) ImGui::SetTooltip("Automatically shoots when crosshair is on target.");
        }
        else if (selectedTab == 1) { // Visuals tab
            ImGui::TextColored(ImVec4(0.20f, 0.40f, 0.50f, 1.00f), "Visual Settings");
            ImGui::Separator();
            ImGui::Checkbox("Enable ESP", &espEnabled); // Using global var
            if (ImGui::IsItemHovered()) ImGui::SetTooltip("Toggles enemy ESP visuals.");
            ImGui::Text("ESP Status: %s", espEnabled ? "Enabled" : "Disabled");
            ImGui::ColorEdit3("ESP Color", espColor);
            if (ImGui::IsItemHovered()) ImGui::SetTooltip("Adjusts the ESP box color.");

            ImGui::Checkbox("Full Boxes", &boxEnabled);
            if (ImGui::IsItemHovered()) ImGui::SetTooltip("Draws full bounding boxes around enemies.");

            ImGui::Checkbox("Corner Boxes", &cornerBoxEnabled);
            if (ImGui::IsItemHovered()) ImGui::SetTooltip("Draws corner lines around enemies.");

            ImGui::Checkbox("Bone ESP", &boneEspEnabled);
            if (ImGui::IsItemHovered()) ImGui::SetTooltip("Draws enemy skeletons.");

            ImGui::Checkbox("Glow", &showGadgetDistance);
            if (ImGui::IsItemHovered()) ImGui::SetTooltip("Adds a glow effect to enemies.");
            if (glowEnabled) { // Check the correct glow variable
                ImGui::SliderFloat("Glow Intensity", &glowIntensity, 0.1f, 1.0f, "%.2f");
                if (ImGui::IsItemHovered()) ImGui::SetTooltip("Adjusts the glow effect strength.");
            }

            ImGui::Checkbox("Health Bars", &showGadgetDistance);
            if (ImGui::IsItemHovered()) ImGui::SetTooltip("Shows health bars next to enemies.");

            ImGui::Checkbox("Enable Radar", &gadgetEspEnabled); // Changed from radarHackEnabled to radarEnabled
            if (ImGui::IsItemHovered()) ImGui::SetTooltip("Shows enemies on radar.");

            ImGui::Separator(); // Separator for new features
            ImGui::Text("Additional ESP Features:");

            ImGui::Checkbox("Names", &nameEspEnabled);
            if (ImGui::IsItemHovered()) ImGui::SetTooltip("Show enemy names/IDs.");

            ImGui::Checkbox("Health Text", &healthTextEnabled);
            if (ImGui::IsItemHovered()) ImGui::SetTooltip("Show enemy health as text.");

            ImGui::Checkbox("Distance", &distanceEspEnabled);
            if (ImGui::IsItemHovered()) ImGui::SetTooltip("Show distance to enemies.");

            ImGui::Checkbox("Snaplines", &snaplinesEnabled);
            if (ImGui::IsItemHovered()) ImGui::SetTooltip("Draw lines from screen bottom to enemies.");

            ImGui::Checkbox("Head Dot", &headDotEnabled);
            if (ImGui::IsItemHovered()) ImGui::SetTooltip("Draw a dot on enemy heads.");

            ImGui::Checkbox("Target FOV Circle", &fovCircleEnabled);
            if (ImGui::IsItemHovered()) ImGui::SetTooltip("Draw a visual FOV circle on screen.");

            ImGui::Checkbox("Line to Closest Enemy", &lineToClosestEnemyEnabled);
            if (ImGui::IsItemHovered()) ImGui::SetTooltip("Draw a line to the closest enemy (within FOV if FOV circle enabled).");

        }
        else if (selectedTab == 2) { // Misc tab
            ImGui::TextColored(ImVec4(0.20f, 0.40f, 0.50f, 1.00f), "Miscellaneous");
            ImGui::Separator();
            ImGui::Checkbox("Teleport iteems (DELETE HOTKEY)", &teleport);
            if (ImGui::IsItemHovered()) ImGui::SetTooltip("Enables automatic bunny hopping.");
        }
        ImGui::EndChild();

        // Footer
        ImGui::Separator();
        float footer_height = ImGui::GetTextLineHeightWithSpacing() + style.FramePadding.y;
        ImGui::SetCursorPosY(ImGui::GetWindowSize().y - footer_height - style.WindowPadding.y);
        ImGui::Text("v0.0.0.00");

        ImGui::End();
    }
} // namespace overlay#pragma once
#define _CRT_SECURE_NO_WARNINGS // Should be the first line, or among the very first
#include "imgui_impl_win32.h" // <<< THIS IS NEEDED FOR THE DECLARATION
#include "imgui_impl_dx11.h"

#define d_toggle_bind 0x2D /* VK_INSERT */
#include <imgui.h> // <-- Include ImGui's main header HERE

namespace overlay
{
    extern bool healthBarEnabled;
    extern float healthBarWidth;
    extern bool healthBarDynamicColor; // New
    extern ImU32 healthBarHighColor;    // New
    extern ImU32 healthBarMidColor;     // New
    extern ImU32 healthBarLowColor;     // N
    extern ImU32 glowColor; // New: Specific color for glow

	void draw_gui();
	void render();
    extern bool weaponEspEnabled;       // New
    extern bool statusEspEnabled;       // New
    extern bool teamEspColoringEnabled; // New
    extern ImU32 friendlyEspColor;      // New
    extern ImU32 enemyEspColor;         // New (can replace general espColor logic)
    extern bool espVisibilityCheckEnabled; // New
    extern ImU32 espVisibleColor;       // New
    extern ImU32 espOccludedColor;      // New
    // Gadget ESP
    extern bool gadgetEspEnabled;       // New
    extern ImU32 gadgetEspColor;        // New
    extern bool showGadgetDistance;         // New
    extern bool showGadgetDistance;     // New
    extern bool exploitSpeedhackEnabled;
    extern float exploitSpeedMultiplier;
    extern bool exploitNoRecoilEnabled; // Highly speculative
    extern bool exploitInfiniteStaminaEnabled;
    // Add more as needed
    extern bool teleport;
        extern bool weaponChamsEnabled;
    extern ImColor weaponChamsColorImGui; // Use ImGui's color picker
    // extern float weaponChamsEmissiveStrength; // Optional: if you want to configure glow

    // Vehicle ESP
    extern bool vehicleEspEnabled;      // New
    extern ImU32 vehicleEspColor;       // New
    extern bool showVehicleName;        // New
    extern bool showVehicleDistance;    // New
    extern bool showVehicleRider;       // New
    extern bool enabled;
    extern bool aimbotEnabled;
    extern float aimbotFov;
    extern bool espEnabled;
    extern float espColor[3];
    extern bool boxEnabled;
    extern float mainEspBoxColor[3];
    extern float mainEspBoxThickness;
    extern bool cornerBoxEnabled;
    extern float cornerEspBoxColor[3];
    extern float cornerEspBoxThickness;
    extern float cornerFraction;
    extern bool glowEnabled;
    extern float glowEspIntensity;
    extern bool healthBarEnabled;
    extern float healthBarWidth;
    extern bool nameEspEnabled;
    extern bool healthTextEnabled;
    extern ImU32 textEspColor;
    extern bool distanceEspEnabled;
    extern float distanceUnitConversion;
    extern bool snaplinesEnabled;
    extern ImU32 snaplineColor;
    extern ImVec2 snaplineOrigin;
    extern bool headDotEnabled;
    extern float headDotRadius;
    extern ImU32 headDotColor;
    extern bool boneEspEnabled;
    extern bool fovCircleEnabled;
    extern float fovCircleRadius;
    extern ImU32 fovCircleColor;
    extern bool lineToClosestEnemyEnabled;
    extern ImU32 lineToEnemyColor;
    extern bool radarEnabled;
    extern bool bhopEnabled;

}
